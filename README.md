**Вопрос 1**

*На языке Python написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций.*

*Пример:* 

*def isEven(value):*
      *return value % 2 == 0*

**Решение 1** (Task1): альтернативным вариантом проверки на чётность будет проверка последнего бита числа. Если он равен 0 - значит число чётное. Такой способ должен быть самым быстродействующим, так как все числа и так хранятся в битах, не нужно проводить операцию деления, нужно только сравнить два последних бита. Однако, вариант с остатком от деления является более читаемым и интуитивно понятным

**Вопрос 2**

*На языке Python написать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.*

*Оценивается:*

*Полнота и качество реализации*
*Оформление кода*
*Наличие сравнения и пояснения по быстродействию*

**Решение 2** (Task2): Для создания циклического буфера FIFO я выбрал 2 фундаментальных типа структур: последовательный массив и связанный список. Главным плюсом последовательного массива должен быть быстрый доступ к элементу (O(1)), так как все элементы идут подряд и находятся по простой формуле: начальный_адрес_массива + (размер_элемента * индекс). Добавление элемента в массив однако является относительно медленной операцией (O(n)) Главным плюсом связанного списка должна быть быстрая вставка элемента (O(1)), так как нужно изменить только связи в соседях. Из-за непоследовательности данных связанного списка, доступ к элементам должен быть относительно медленный (O(n)). 
Далее приведены результаты тестирования быстродействия обеих структур:
Время добавления (10000000)
	Буфер на базе массива:
	2.4487228393554688 сек
	Буфер на базе связанного списка:
	7.821777105331421 сек
Время взятия (10000000)
	Буфер на базе массива:
	2.3074216842651367 сек
	Буфер на базе связанного списка:
	3.076099157333374 сек
На практике, вариант буфера на базе массива является быстрее как при добавлении, так и при извлечении элемента. Скорее всего, это связано с тем, что буфер на базе последовательного массива работает с оптимизированным, встроенным в Python списком, тогда как буфер на базе связанного списка использует самописный класс Node.
