**Вопрос 1**

*На языке Python написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций.*

*Пример:* 

*def isEven(value):*
      *return value % 2 == 0*

**Решение 1** (Task1): альтернативным вариантом проверки на чётность будет проверка последнего бита числа. Если он равен 0 - значит число чётное. Такой способ должен быть самым быстродействующим, так как все числа и так хранятся в битах, не нужно проводить операцию деления, нужно только сравнить два последних бита. Однако, вариант с остатком от деления является более читаемым и интуитивно понятным

**Вопрос 2**

*На языке Python написать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.*

*Оценивается:*

*Полнота и качество реализации*
*Оформление кода*
*Наличие сравнения и пояснения по быстродействию*

**Решение 2** (Task2): Для создания циклического буфера FIFO я выбрал 2 фундаментальных типа структур: последовательный массив и связанный список. 

Главный плюс буфера на основе последовательного массива это быстрый доступ к элементам (**O(1)**), добавление и удаление происходит по индексу, который высчитывается элементарными математическими операциями.Также, за основу был взять список Python, что сильно упрощает реализацию и читаемость кода.

Второй вариант буфера реализован на базе связанного списка. Для этой такой структуры, я использовал дополнительный класс Node, который хранит в себе значение, а также ссылки на своих соседей. Данный вариант проигрывает буферу на основе последовательного списка по быстродействию, однако, он обладает большей гибкостью для дальнейших расширений функционала, более удобен для сложных объектов. Циклическая структура образуется естественным образом (в отличии от массива).

Далее приведены результаты тестирования быстродействия обеих структур на практике, при добавлении и взятии 10'000'000 чисел:

Время добавления (10'000'000)
	Буфер на базе массива:
	2.4487228393554688 сек
	Буфер на базе связанного списка:
	7.821777105331421 сек

Время взятия (10'000'000)
	Буфер на базе массива:
	2.3074216842651367 сек
	Буфер на базе связанного списка:
	3.076099157333374 сек

Как и ожидалось, вариант буфера на базе последовательного массива является быстрее как при добавлении, так и при извлечении элемента. Для работы с простыми данными, можно смело рекомендовать подход с последовательным массивом.

**Вопрос 3**

*На языке Python предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить, почему вы считаете, что функция соответствует заданным критериям.*

**Решение 3** (Task3): 
